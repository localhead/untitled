'use strict';

///////////////////////////////////////
// Modal window Script Start
const modal = document.querySelector('.modal');
const overlay = document.querySelector('.overlay');
const btnCloseModal = document.querySelector('.btn--close-modal');
const btnsOpenModal = document.querySelectorAll('.btn--show-modal');

const openModal = function (event) {
  event.preventDefault();
  modal.classList.remove('hidden');
  overlay.classList.remove('hidden');
};

const closeModal = function () {
  modal.classList.add('hidden');
  overlay.classList.add('hidden');
};

btnsOpenModal.forEach(function (btn) {
  btn.addEventListener('click', openModal);
});

btnCloseModal.addEventListener('click', closeModal);
overlay.addEventListener('click', closeModal);

document.addEventListener('keydown', function (e) {
  if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
    closeModal();
  }
});
// Modal window Script Ends here
/* 



*/
// Showing cookie message.
// All you need for using this cookie message is is line of script and CSS
// (html is generated by this script)
// Creating new div and store a variable it in
const message = document.createElement('div');
// adding a class to that new div
message.classList.add('cookie-message');
// then we store a text inside that div
message.innerHTML = `We use cookies to improve 
functionality and analytics. <button class = 
"btn btn--close-cookie">Got it.</button>`;
// then we choose a place when we want to place this new div with a text inside
document.querySelector('.header').append(message);
// Closing cookie message by choosing btn we created inside that new div
document
  .querySelector('.btn--close-cookie')
  .addEventListener('click', function () {
    //message.remove();
    message.classList.add('hidden');
  });
/*

*/
// Styling that cookie message inside of JS
message.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
message.style.width = '120%';
message.style.position = 'fixed';
message.style.bottom = '0';
// this allows you to see the properties of created element
console.log(getComputedStyle(message).height); // 46.6667px

// Do some calculation with height. because it is a
// string 46.6667px - we need get rid of 'px' at the end
message.style.height =
  Number.parseFloat(getComputedStyle(message).height, 10) + 30 + 'px';
/* 



*/
// Smooth Scroll while clicking 'learn more' button
//
const btnScroll = document.querySelector('.btn--scroll-to');
const sectionToScrool = document.querySelector('#section--1');

btnScroll.addEventListener('click', function (btnThatClicked) {
  // Thanks to this command we can see the position of page's element
  // relative on user scrolling position (ew - it changes)
  // Section1 in this case
  const s1coordinats = sectionToScrool.getBoundingClientRect();
  console.log(s1coordinats);

  // btn that is clicked position
  console.log(btnThatClicked.target.getBoundingClientRect());

  // with whis command you can get properties of scrolling in general
  console.log('Current Scroll (X/Y: ', window.pageXOffset, window.pageYOffset);

  // viweport log
  // The real time user's window height and width view
  // Use small browser's window and fullscreen to see the result's difference
  console.log(
    document.documentElement.clientHeight,
    document.documentElement.clientWidth
  );

  // !!! Scrolling script starts here
  // Because everything is relative to user's viewport
  // we need to add (+ window.)
  // for each position

  // Making non-smooth animation scroll
  /* 
    window.scrollTo(
    s1coordinats.left + window.pageXOffset,
    s1coordinats.top + window.pageYOffset
  );
  */

  // Making smooth animation
  /* 
    window.scrollTo({
    left: s1coordinats.left + window.pageXOffset,
    top: s1coordinats.top + window.pageYOffset,
    behavior: 'smooth',
  });
  */

  // Modern Approach of doing the same thing (works only on new browsers)
  sectionToScrool.scrollIntoView({ behavior: 'smooth' });
});
/* 


*/
// Smooth scrolling while clicking nav buttons

// This a first approach. However it is not efficient.
// Cuz it actually makes coppies of eventHandlers for each link
// Might cause bad performance if there will be a lot of ellemnts
/* 
document.querySelectorAll('.nav__link').forEach(function (elem) {
  elem.addEventListener('click', function (event) {
    // Removing default scrolling caused by anchors
    event.preventDefault();
    // We need the link form nav__link
    const id = this.getAttribute('href'); //#section--1,2,3
    console.log('Link');
    document.querySelector(id).scrollIntoView({ behavior: 'smooth' });
  });
}); 
*/

// here is the second approach for smmoth nav buttons scrolling
// We will use an event delegation
// We will try to detect and catch the event we need in parent element.
// Yes I hope U know that event in child will also appear in
// parents ellements as well

// sooo, LETS TRY EVENT DELEGATION
// 1) Add event listener to parent element
// 2) Detect which element originated the event

document
  .querySelector('.nav__links')
  .addEventListener('click', function (event) {
    console.log(event.target); // <a class="nav__link" href="#section--1">Features</a>
    // Removing default scrolling caused by anchors
    event.preventDefault();
    // lets work only with child elements. Not the parent
    if (event.target.classList.contains('nav__link')) {
      console.log('Yeah');
      // We need the link form nav__link
      const id = event.target.getAttribute('href'); //#section--1,2,3
      console.log('Link');
      document.querySelector(id).scrollIntoView({ behavior: 'smooth' });
    }
  });
