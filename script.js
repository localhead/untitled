'use strict';

///////////////////////////////////////
// Modal window Script Start
const modal = document.querySelector('.modal');
const overlay = document.querySelector('.overlay');
const btnCloseModal = document.querySelector('.btn--close-modal');
const btnsOpenModal = document.querySelectorAll('.btn--show-modal');

const openModal = function (event) {
  event.preventDefault();
  modal.classList.remove('hidden');
  overlay.classList.remove('hidden');
};

const closeModal = function () {
  modal.classList.add('hidden');
  overlay.classList.add('hidden');
};

btnsOpenModal.forEach(function (btn) {
  btn.addEventListener('click', openModal);
});

btnCloseModal.addEventListener('click', closeModal);
overlay.addEventListener('click', closeModal);

document.addEventListener('keydown', function (e) {
  if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
    closeModal();
  }
});
// Modal window Script Ends here
/* 



*/
// Showing cookie message.
// All you need for using this cookie message is is line of script and CSS
// (html is generated by this script)
// Creating new div and store a variable it in
const message = document.createElement('div');
// adding a class to that new div
message.classList.add('cookie-message');
// then we store a text inside that div
message.innerHTML = `We use cookies to improve 
functionality and analytics. <button class = 
"btn btn--close-cookie">Got it.</button>`;
// then we choose a place when we want to place this new div with a text inside
document.querySelector('.header').append(message);
// Closing cookie message by choosing btn we created inside that new div
document
  .querySelector('.btn--close-cookie')
  .addEventListener('click', function () {
    //message.remove();
    message.classList.add('hidden');
  });
/*

*/
// Styling that cookie message inside of JS
message.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
message.style.width = '120%';
message.style.position = 'fixed';
message.style.bottom = '0';
// this allows you to see the properties of created element
console.log(getComputedStyle(message).height); // 46.6667px

// Do some calculation with height. because it is a
// string 46.6667px - we need get rid of 'px' at the end
message.style.height =
  Number.parseFloat(getComputedStyle(message).height, 10) + 30 + 'px';
/* 



*/
// Smooth Scroll while clicking 'learn more' button
//
const btnScroll = document.querySelector('.btn--scroll-to');
const sectionToScrool = document.querySelector('#section--1');

btnScroll.addEventListener('click', function (btnThatClicked) {
  // Thanks to this command we can see the position of page's element
  // relative on user scrolling position (ew - it changes)
  // Section1 in this case
  const s1coordinats = sectionToScrool.getBoundingClientRect();
  console.log(s1coordinats);

  // btn that is clicked position
  console.log(btnThatClicked.target.getBoundingClientRect());

  // with whis command you can get properties of scrolling in general
  console.log('Current Scroll (X/Y: ', window.pageXOffset, window.pageYOffset);

  // viweport log
  // The real time user's window height and width view
  // Use small browser's window and fullscreen to see the result's difference
  console.log(
    document.documentElement.clientHeight,
    document.documentElement.clientWidth
  );

  // !!! Scrolling script starts here
  // Because everything is relative to user's viewport
  // we need to add (+ window.)
  // for each position

  // Making non-smooth animation scroll
  /* 
    window.scrollTo(
    s1coordinats.left + window.pageXOffset,
    s1coordinats.top + window.pageYOffset
  );
  */

  // Making smooth animation
  /* 
    window.scrollTo({
    left: s1coordinats.left + window.pageXOffset,
    top: s1coordinats.top + window.pageYOffset,
    behavior: 'smooth',
  });
  */

  // Modern Approach of doing the same thing (works only on new browsers)
  sectionToScrool.scrollIntoView({ behavior: 'smooth' });
});
/* 


*/
// Smooth scrolling while clicking nav buttons

// This a first approach. However it is not efficient.
// Cuz it actually makes coppies of eventHandlers for each link
// Might cause bad performance if there will be a lot of ellemnts
/* 
document.querySelectorAll('.nav__link').forEach(function (elem) {
  elem.addEventListener('click', function (event) {
    // Removing default scrolling caused by anchors
    event.preventDefault();
    // We need the link form nav__link
    const id = this.getAttribute('href'); //#section--1,2,3
    console.log('Link');
    document.querySelector(id).scrollIntoView({ behavior: 'smooth' });
  });
}); 
*/

// here is the second approach for smmoth nav buttons scrolling
// We will use an event delegation
// We will try to detect and catch the event we need in parent element.
// Yes I hope U know that event in child will also appear in
// parents ellements as well

// sooo, LETS TRY EVENT DELEGATION
// 1) Add event listener to parent element
// 2) Detect which element originated the event

document
  .querySelector('.nav__links')
  .addEventListener('click', function (event) {
    //console.log(event.target); // <a class="nav__link" href="#section--1">Features</a>
    // Removing default scrolling caused by anchors
    event.preventDefault();
    // lets work only with child elements. Not the parent
    if (event.target.classList.contains('nav__link')) {
      // We need the link form nav__link
      const id = event.target.getAttribute('href'); //#section--1,2,3
      document.querySelector(id).scrollIntoView({ behavior: 'smooth' });
    }
  });
/* 



*/
// Tabbed component in operations
const tabs = document.querySelectorAll('.operations__tab');
const tabsContainer = document.querySelector('.operations__tab-container');
const tabsContent = document.querySelectorAll('.operations__content');

// Using event delegation to reach each tab
tabsContainer.addEventListener('click', function (event) {
  // Choosing parent elem so every click will be on whole element
  // but not child elements inside.
  // To do that we use closest,
  // which will refer on next closest parent/child element
  const clickedElem = event.target.closest('.operations__tab');
  console.log(clickedElem);
  // <button class="btn operations__tab operations__tab--2 operations__tab--active" data-tab="2"> <span>02</span>Instant Loans</button>
  // And we also have to get rid of clicking on parent element
  // If we clicked on parent element - this event handler will return null.
  // and we stop the execution
  if (clickedElem === null) return;

  // removing class on all tabs
  tabs.forEach(function (tab) {
    tab.classList.remove('operations__tab--active');
  });
  // adding shift on active tab
  clickedElem.classList.add('operations__tab--active');

  // removing all content before showing appropriate
  tabsContent.forEach(function (elem) {
    elem.classList.remove('operations__content--active');
  });

  // adding appropriate content to tab number
  console.log(clickedElem.dataset);
  console.log(clickedElem.dataset.tab); // 1,2,3
  document
    .querySelector(`.operations__content--${clickedElem.dataset.tab}`)
    .classList.add('operations__content--active');
});
/* 


*/
// Menu fade animation while hovering
const nav = document.querySelector('.nav');
const handleHover = function (event, opacity) {
  if (event.target.classList.contains('nav__link')) {
    // link which is covered by mouse
    const link = event.target;
    console.log(link); // <a class="nav__link" href="#section--2">Operations</a>
    // rest of the links which are not covered by mouse
    const siblings = link.closest('.nav').querySelectorAll('.nav__link');
    // logo itself
    const logo = link.closest('.nav').querySelector('img');

    const button = link.closest('.nav').querySelector('.nav__link--btn');

    siblings.forEach(function (elem) {
      if (elem !== link) elem.style.opacity = opacity;
    });
    logo.style.opacity = opacity == 1 ? 1 : 0.7;
  }
};

// changing opacity while covering
nav.addEventListener('mouseover', function (event) {
  handleHover(event, 0.4);
});
// bind ussage. same as above. but with bind
nav.addEventListener('mouseout', function (event) {
  handleHover(event, 1);
});
/* 



*/
/* 
// Sticky navigation while scrolling using Scroll Event
// (not the best way of making sticky navigation)

// Saving a class where we will add new class to
const navToAddClass = document.querySelector('.nav');
// Saving a place from where we will add that class
const navTopAttach = document.querySelector('#section--1');
// Saving a coordinats of that place
const navTopAttachCoords = navTopAttach.getBoundingClientRect();
console.log(navTopAttach.getBoundingClientRect());

// Scroll event is bad for performance because its triggers all the time
window.addEventListener('scroll', function () {
  //console.log(this.window.scrollY);
  // Adding new class if user scrooled to section--1
  if (this.window.scrollY > navTopAttachCoords.top) {
    console.log(navTopAttachCoords.top);
    navToAddClass.classList.add('sticky');
  } else navToAddClass.classList.remove('sticky');
});
*/
/* 



*/
// Sticky Navigation but with using Intersection Observer API
// some theory here. Uncomment and watch logs
/* 
const observerCallback = function (entries, observer) {
  entries.forEach(function (entry) {
    console.log(entry);
  });
};

const observerOptions = {
  // element which we want to intersect
  root: null,
  threshold: 0.1,
};

const observer = new IntersectionObserver(observerCallback, observerOptions);

// observing a certain target
observer.observe(sectionToScrool); 

// End of Intersection Observer API theory. Now lets use it in practice
//
//
*/
// what we want to show
const navToAddClass = document.querySelector('.nav');
// where we want to show
const header = document.querySelector('.header');
// getting exat margin from where we want to show
const navHeight = navToAddClass.getBoundingClientRect().height;

// conditions in which our function will trigger
const obsOptions = {
  // dont really know why we use null here
  root: null,
  // we want nav to show up when generic nav is out of viewport
  threshold: 0,
  // we make nav bar appear a bit earlier before section
  // but its better to calculate it dynamicly in order to have a good
  // responsive design. (hardcoding 90px is not always a good idea)
  // rootMargin: '-90px',
  rootMargin: `-${navHeight}px`,
};

// fucntion which will trigger
const obsCallback = function (entries, observer) {
  const [entry] = entries;
  //console.log(entry);

  if (!entry.isIntersecting) navToAddClass.classList.add('sticky');
  else navToAddClass.classList.remove('sticky');
};

// Observer function which will trigger everything
const headerObserver = new IntersectionObserver(obsCallback, obsOptions);
// paste into the argument place where you need event to be triggered
headerObserver.observe(header);
/* 





*/
// Smooth Revealing sections while scrolling down
// To do that I use Intersection Observer API again

// where to reveal sections?
const allSections = document.querySelectorAll('.section');

// options for observimg
const revealSectionOptions = {
  root: null,
  threshold: 0.15,
};

// the function which will reveal pages
const revealSection = function (entries, observer) {
  const [entry] = entries;
  //console.log(entry);

  // if section is not intersectin - do nothing
  if (!entry.isIntersecting) return;
  // if it does remove class
  else entry.target.classList.remove('section--hidden');
  // onse we observe the section - we removed the class from it
  // after that - we should stop observing it
  observer.unobserve(entry.target);
};

// the main observer trigger with options and function
const sectionObserver = new IntersectionObserver(
  revealSection,
  revealSectionOptions
);

// cuz we have several section and not one, we have to observe on all of them
// with looping over and placing and observe method on each of them
allSections.forEach(function (section) {
  section.classList.add('section--hidden');
  sectionObserver.observe(section);
});
/* 




*/
// Lazy loading Images Feature
// To do that I use Intersection Observer API again

// where to reveal sections?
// selecting only these imgs that has data-src attribute
const imgTargets = document.querySelectorAll('img[data-src]');

const revealImgOpt = {
  root: null,
  threshold: 0,
  // lets load lazy img sooner
  rootMargin: '200px',
};

const revealImgFunc = function (images, observer) {
  const [img] = images;
  console.log(img);

  // guard close. Means - do smt if only intersecting
  if (!img.isIntersecting) return;

  // replace src with data-src
  // src is low res img. And we need to change it with HiRes img
  // which is located in data-src="img/card.jpg" attribute in html
  img.target.src = img.target.dataset.src;

  // Now its time to remove blur filter.
  // However we do not want to remove it immideatly
  // because we do not want want to show blured image if it needs some time to load
  // thats why we have to listen to the 'load' event to be done when HiRes img loads completely
  img.target.addEventListener('load', function () {
    img.target.classList.remove('lazy-img');
  });
  observer.unobserve(img.target);
};

const imgObserver = new IntersectionObserver(revealImgFunc, revealImgOpt);

imgTargets.forEach(function (img) {
  imgObserver.observe(img);
});
